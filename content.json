{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"hello-world","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/0323/hello-world.html"},{"title":"java开发桌面应用（一）JavaFx初体验Jfoenix UI+Scene Builder","text":"故事发生在两个月前，哈工大的同学找到我，他的老师之前接了个海绵城市系统评价相关的项目，最后的提交里需要有一个桌面应用。之前我对桌面开发没多了解，但想到咱java无所不能，加上顺手谷歌一下看到javafx能做。既然能做那就不是问题，帮他这个忙啦～ 目前主流的桌面开发，跨平台用qt，不跨平台用winform或wpf。 javafx虽然不太主流，但是也能做啦～ 常用的开发套路：javafx 框架 + Jfoenix UI控件 + Scene Builder可视化工具 下面举个简单的小栗子来初步感受吧～ （ 源码记录 环境准备： IntelliJ IDEA JDK 1.8 Scene Builder 8.5.0 1.新建一个javafx项目使用IDEA自带的新建项目菜单即可 目录结构如下，直接点击Main运行，效果如右图 接下来可以大致感受javafx框架的想法，项目从Main.java进入，加载view层sample.fxml，窗口设置title和scene参数后展出。sample.fxml与controller层Controller.java进行行为绑定。与MVC类似，理解起来比较容易，接下来就开始玩吧～ 2.添加Maven为方便引入三方库管理项目，引入Maven。 首先将设置里Maven配置修改为自己提前安装好的maven地址。 引入maven 右键项目名选择 Add Framework Support... ，选择Maven确认，并修改一下目录结构。 注：将sample.fxml移动到resource目录下需修改Main.java中的加载路径FXMLLoader.load(getClass().getResource(&quot;/sample.fxml&quot;)) 3.引入Jfoenix UI库Jfoenix项目地址及Components演示 项目引入：pom.xml 文件里添加 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.jfoenix&lt;/groupId&gt; &lt;artifactId&gt;jfoenix&lt;/artifactId&gt; &lt;version&gt;8.0.8&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; scene builder工具引入 图中第二步从Maven仓库找到刚下载好的 jfoenix-8.0.8.jar，第三步全部或按需引入。 完成后在Library的Custom栏即引入的Jfoenix组件。 4.使用scene builder编写界面通过scene builder工具可视化编写.fxml视图文件。 打开设置，建立IDEA与scene builder工具关联 这样选中sample.fxml文件右键点击 Open In SceneBuilder 即可直接打开scene builder可视化编辑该文件。 scene builder编辑演示 简单说明， 图中引入三个组件，AnchorPane做背景板，一个按钮JFXButton，一个文本栏JFXTextField 右侧code栏处，JFXButton的Id名设置为button，响应方法名为changeInput。JFXTextField的Id名为textField，无响应方法。 左侧Controller指定sample.fxml的控制器Controller.java，方便自动生成Controller代码 使用自动生成的Controller代码 打开scene builder工具左上角 View / Show Simple Controller Skeleton，复制粘贴至项目中Controller.java，然后再编辑省时省力～ 更新项目中sample.fxml 工具里 点保存 ！！。 预览效果 在scene builder工具使用中不免想预览界面效果，左上角 Preview / Show Preview in Window 5.初体验 简单编写Controller.java完成组件的行为响应。 1234567891011121314151617181920212223242526package sample;import com.jfoenix.controls.JFXButton;import com.jfoenix.controls.JFXTextField;import javafx.event.ActionEvent;import javafx.fxml.FXML;public class Controller { @FXML private JFXButton button; @FXML private JFXTextField textField; @FXML void changeInput(ActionEvent event) { String text = textField.getText(); if (text.equals(\"hello\")){ textField.setText(\"world!\"); }else{ textField.setText(\"\"); } }} 运行效果 还挺好玩的～","link":"/2020/0327/javafx01-helloworld.html"},{"title":"java开发桌面应用（二）JavaFx美化FontAwesomeFX+CSS","text":"一个桌面应用除了功能完善，美化界面也很必要。 上一期引入的Jfoenix UI控件也算美化的一种，各个组件较原Javafx组件有很大的提升。 为了美化桌面应用more，建议引入字体图标FontAwesomeFX和写好各个组件的CSS。 了解前面的文章有助于接下来理解： java开发桌面应用（一）JavaFx初体验 Jfoenix UI+Scene Builder 1.FontAwesomeFX字体图标一个好看的前端往往离不开字体图标的使用，在javafx可以使用FontAwesomeFX字体图标～ 类比在web前端使用FontAwesome字体图标： 引入：html文件的&lt;head&gt;中加入&lt;link href=&quot;//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt; 浏览并选择：浏览FontAwesome官网，选择想用的图标，复制其代号如 bath 使用：&lt;i class=&quot;fa fa-bash&quot;&gt;&lt;/i&gt; 亦可参考YouTube：Fontawesome-Fx : Make your JavaFX App Attractive with Awesome Icons 1.1 引入与上一篇 java开发桌面应用（一）JavaFx初体验 引入Jfoenix UI库类似 项目引入 12345&lt;dependency&gt; &lt;groupId&gt;de.jensd&lt;/groupId&gt; &lt;artifactId&gt;fontawesomefx&lt;/artifactId&gt; &lt;version&gt;8.9&lt;/version&gt;&lt;/dependency&gt; scene builder工具引入 从Maven本地仓库找到刚刚下载好的fontawesomefx-8.9.jar 1.2 浏览并选择不同于FontAwesome在网页直接浏览，FontAwesomeFX的作者写了一个图标浏览桌面应用，下载链接，解压后打开 bin 目录，按Mac或Windows双击不同程序。 1.3 使用以上图选中照相机代号CAMERA_RETRO为例，直接使用FontAwesomeIconView组件（对应1.2中左侧FontAwesome类），也可将其嵌入到按钮等中，只需在组件Properties的Glyph Name中写入图标名。 彩蛋（强迫症要s）首先以下不影响使用，无兴趣可忽略！ 细心的朋友可能发现了，1.2 中的图标浏览桌面应用作者是以 FontAwesomeFX 8.15 开发的，而我们在 1.1 中引入的却是 FontAwesomeFX 8.9 ，为什么呢？ 查询一番发现 8.9 之后的版本，作者停止在 Maven Central更新，换成 bintray。换也无所谓，有jar包用就行。可自此后新的jar包不仅更名为 fontawesomefx-common-8.1X.jar ，且在 scene builder工具引入过程中只有一个GlyphsStack的组件，这还怎么玩？ 所以他这么做且后续继续更新FontAwesomeFX的意义是什么呢？翻了一圈也没get他的想法，直到逛了他github给出的examples。示例里界面的图标全是直接code进页面，没通过fxml用scene builder工具构建，例如： 123456789VBox root = new VBox();WeatherIconView weatherIcon = new WeatherIconView(WeatherIcon.CLOUDY);root.getChildren().add(weatherIcon);Scene scene = new Scene(root, 500, 500);primaryStage.setScene(scene);primaryStage.setTitle(\"FontAwesomeFX Basic Demo\");primaryStage.show(); 仔细看，第二行的类似代码在 1.2 图标浏览桌面应用下方有显示。 （所以我浅显地猜测可能原因是，在8.9之后作者的项目知名度已可，于是他懒得将新的jar包与scene builder工具做适配。加上如果对javafx的code足够熟练，也无需借助工具）。 划重点：scene builder工具只是辅助写fxml和生成部分controller内容，javafx项目完全可以不需要该工具使用直接code出界面，甚至也可不需要fxml。 Fine！初学者还是工具香～ 2.CSS如图所示，在默认情况下，Pane组件的背景色为白色，而JFXHamburger为黑色。 好！现在我们想Pane组件的背景色为黑色，而JFXHamburger中三条杠为白色。 双击选中组件，可以修改组件里的style选项里的css属性，但是问题出现了。Pane组件的背景颜色通过-fx-background-color属性很容易修改，但JFXHambuger的-fx-background-color属性修改并不是将三条黑杠变成白色，而是杠后的背景，且下拉的其他属性也无用。 原因：三条杠属于JFXHambuger的内部StackPane选择器，无法在Scene Builder工具中靠双击选中，也就是说该工具里无法编辑。 解决方法：统一在stylesheet引入css文件，这样即可自由指定选择器，自由指定css属性，也便于后期维护。 具体选择器和属性参考JavaFX CSS 、JFoenix CSS 或 JFoenix官方的demo。 某些选择器不确定时可在style里的Id处（或直接fxml上）指定Id，通过Id选择器修改。 这样就解决了～ 划重点：建议布局和样式分开，fxml 管布局，css 管样式。 小提示：Scene Builder工具编辑完点保存才能同步fxml噢～","link":"/2020/0329/javafx02-beautify.html"},{"title":"java开发桌面应用（三）JavaFx写一个抽屉式导航","text":"有了前两篇的基础后，开始写一个抽屉式导航～ （ 源码记录 运行效果 了解前面的文章有助于接下来理解： java开发桌面应用（一）JavaFx初体验 Jfoenix UI+Scene Builder java开发桌面应用（二）JavaFx美化FontAwesomeFX+CSS 1.学习思路学习一个新技术，我习惯先从简单的例子去感受它的样子。然后从教学视频中快速了解它常用的操作细节和整体思维逻辑，并与一些现有的该技术的项目进行比对。期间有疑问的地方到处翻博客～一般到这里，即可用它做出类似的项目了。 当然，前面的一切是为了省时省力，后续如果需要深入解决问题，熟悉官方文档和源码才是更好的选择。 参考JFoenix官方的demo 官方的项目用Gradle管理，demo模块是整体项目的子模块。然而demo模块里的类用到了外部模块的类。IDEA单独运行demo模块不可，运行整体项目前期加载配置太复杂，且后期运行demo时间长（或许是我不太懂Gradle配置吧，运行起来总有点问题）。 于是为了省时省力，索性单独新建了个Maven项目，复制粘贴好官方demo，配好依赖。这样运行学习起来方便又快。放在这里 注意：demo里运行到了lambda表达式，所以需要将IDEA里两个地方：Project Structure / Modules / Language level 和 设置里 Java Compiler 的 Target bytecode version 改为 8 或 1.8 YouTube视频：JavaFX Java GUI Design Tutorials 基本一看就懂，如果听不太懂英文，右下角有即时识别语言并翻译。 GitHub项目集合：AwesomeJavaFX 逛逛找灵感～ 2.JXFHamburger图标动画 Scene Builder工具里选取 JFXHamburger 组件放到合适的位置， 然后在controller中固定操作： 123456789@FXMLpublic void initialize() { HamburgerBackArrowBasicTransition ht = new HamburgerBackArrowBasicTransition(hamburger); ht.setRate(-1); hamburger.addEventHandler(MouseEvent.MOUSE_PRESSED, e -&gt; { ht.setRate(ht.getRate() * -1); ht.play(); });} 不喜欢HamburgerBackArrowBasicTransition 这种动画切换模式可以试试其他HamburgerXXXXXTransition ～ 3.JFXDrawer抽屉希望 JFXHamburger 切换的同时可以带着 JFXDrawer 切换。同时在抽屉打开的情况下，点击顶栏下的空白面板处抽屉也关闭～ 通过demo推荐的 JFXDrawersStack 和 JFXDrawer 来解决，分以下四步： ​ 1. 新建一个drawer.fxml，用 VBox 组件画一个黑面板 ​ 注意长宽大小，背景色等样式一律交由CSS文件。 ​ 2. 将获取的 VBox注入到新new的 JFXDrawer 123456789101112131415161718private JFXDrawer leftDrawer;@FXMLpublic void initialize() { leftDrawer = new JFXDrawer(); VBox vBox = null; try { vBox = FXMLLoader.load(getClass().getResource(\"/fxml/drawer.fxml\")); } catch (IOException e) { e.printStackTrace(); } leftDrawer.setSidePane(vBox);//注入 //leftDrawer.setDirection(JFXDrawer.DrawerDirection.LEFT); 默认LEFT leftDrawer.setDefaultDrawerSize(160);//与vBox宽对应 leftDrawer.setResizeContent(false); leftDrawer.setOverLayVisible(false); leftDrawer.setResizableOnDrag(true);} ​ 3. 将新new的 JFXDrawersStack 绑定到主面板中 123456789@FXMLprivate AnchorPane body;@FXMLpublic void initialize() { drawersStack = new JFXDrawersStack(); //drawersStack.setLayoutX(100); drawer的起始位置x定点，默认0，y同。 body.getChildren().add(drawersStack);} ​ 4. JFXHamburger 通过 JFXDrawersStack 控制 JFXDrawer 的切换 12345678910111213141516171819202122232425@FXMLprivate AnchorPane content; //content为顶栏下的空白面板@FXMLpublic void initialize() { //hamburger点击动态切换 ht = new HamburgerBackArrowBasicTransition(hamburger); ht.setRate(-1); hamburger.addEventHandler(MouseEvent.MOUSE_PRESSED, e -&gt; { toggerDrawer(); }); //抽屉打开状态下，点击content抽屉以关闭 content.addEventHandler(MouseEvent.MOUSE_CLICKED, (e) -&gt; { if (ht.getRate()!= -1){ toggerDrawer(); } });}private void toggerDrawer() { ht.setRate(ht.getRate() * -1); ht.play(); drawersStack.toggle(leftDrawer);} 4.抽屉栏实现页面切换主要思路是： ​ 1. 抽屉栏里写菜单按钮 注意定义好每个按钮的 Accessible Text属性，方便第三步识别～ ​ 2. 简单新建多个fxml页面，与按钮对应 我的是happy、balance、health.fxml～ ​ 3. 当点击每个菜单按钮的时候，空白面板刷新成不同的fxml 为了好看和方便指引，在顶栏加入了 title和titleIcon 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@FXMLprivate Label title;@FXMLprivate FontAwesomeIconView titleIcon;@FXMLpublic void initialize() { leftDrawer = new JFXDrawer(); VBox vBox = null; try { vBox = FXMLLoader.load(getClass().getResource(\"/fxml/drawer.fxml\")); } catch (IOException e) { e.printStackTrace(); } for (Node node: vBox.getChildren()){ if (node.getAccessibleText() != null){ node.addEventHandler(MouseEvent.MOUSE_CLICKED, (e) -&gt; { refreshPage(node.getAccessibleText()); toggerDrawer(); }); } } leftDrawer.setSidePane(vBox); refreshPage(\"Happy\"); //初始化页面} private void refreshPage(String page){ try { content.getChildren().clear(); AnchorPane contentPage = FXMLLoader.load(getClass().getResource(\"/fxml/\" + page + \".fxml\")); content.getChildren().add(contentPage); switch (page){ case \"Happy\" : { title.setText(\"Happy\"); titleIcon.setGlyphName(\"CAMERA\"); return; } case \"Balance\": { title.setText(\"Balance\"); titleIcon.setGlyphName(\"BALANCE_SCALE\"); return; } case \"Health\" : { title.setText(\"Health\"); titleIcon.setGlyphName(\"MEDKIT\"); return; } } } catch (IOException e) { e.printStackTrace(); }} 这样就做出最开始想要的效果啦～ 提示：所有的样式在css文件里写明～ 以上的controller文件为了说明思路 分别写出，可能显的比较杂乱。完整版见 Github 。","link":"/2020/0330/javafx03-drawer.html"},{"title":"java开发桌面应用（四）JavaFx与excel交互","text":"有了前三篇的学习基础，这一篇来解决最开始的需求，即同学要求的海绵城市系统评价的桌面应用～ 听起来高大上，实际上very normal～ 即在应用中设计了多个评价模型，监测机构的用户在将监测数据统计到Excel后，使用该应用计算出所需要的控制参数。 简而言之，核心即处理Excel里的数据。 （你没看错，连自动监测都不需要，科研经费真好pian。当然桌面应用只是其中一环，需要 SCI 给项目结题交差啦… Fine，这一篇就以其中一个简单的模型来讲述 Javafx怎么与Excel交互吧～（ 源码记录 了解前面的文章有助于接下来理解： java开发桌面应用（一）JavaFx初体验 Jfoenix UI+Scene Builder java开发桌面应用（二）JavaFx美化FontAwesomeFX+CSS java开发桌面应用（三）JavaFx写一个抽屉式导航 以排水分区面源污染模型为例，$$R = (1 - \\frac{\\sum_{j=1}^pC_jQ_j}{\\sum_{i=1}^nC_iQ_i+\\sum_{k=1}^qm_kS_k})*100%$$其中： ​ R - 降雨径流面源污染控制率，%； ​ Ci、 Cj - 不同监测点降雨入流及外排污染物平均浓度，mg/L； ​ Qi、 Qj - 不同监测点降雨入流及外排污染物流量，L/s； ​ n、p - 入流及外排监测取样总数； ​ mk - 不同下垫面场次降雨径流污染物输出系数，mg/m2 s； ​ Sk - 不同下垫面面积，m2； ​ q - 下垫面总数； 运行效果 1.设计Excel模版应用是面向用户的，自然需要Excel模版来引导用户填数据～ 提醒用户从第三行输入数据。 模型公式很简单，分为入流、出流和垫面三组。值得注意的是三组的行数n、p、q是不确定的，之后有扫描excel拿数据的亮点…(也不算多亮，稍微动脑子的地方哈～ 2.生成Excel模版给用户主要分为两步， 选择保存的路径及命名 模版写至Excel并导出 2.1 选择保存路径及命名与文件交互，使用javafx提供的 FileChooser 类 。这里用到它的 showSaveDialog 方法来保存文件。（之后也用它的 showOpenDialog 方法来导入文件 写一个工具类 FileChooserUtil ： 123456789101112131415161718192021public class FileChooserUtil { public static File chooseSaveFile(String defaultFileName, FileChooser.ExtensionFilter... extensionFilter) { File file = null; try { FileChooser fileChooser = new FileChooser(); fileChooser.setInitialDirectory(new File(System.getProperty(\"user.home\"))); if (defaultFileName != null) { fileChooser.setInitialFileName(defaultFileName); } if (extensionFilter != null) { fileChooser.getExtensionFilters().addAll(extensionFilter); } file = fileChooser.showSaveDialog(new Stage()); } catch (NullPointerException e) { e.printStackTrace(); } return file; }} defaultFileName为默认保存的文件名，FileChooser.ExtensionFilter为需要的过滤后文件类型，看一眼 2.2 就明白啦。 2.2 导出Excel模版 与Microsoft Office交互一般使用大名鼎鼎的Apache POI。 但为了节约学习成本，我这里使用的是也很出名Java工具类库 Hutool ，它的Excel工具-ExcelUtil对poi进行了简单的封装，很容易便能看懂使用，非常方便～ 引入hutool 因为ExcelUtil针对Apache POI的封装，因此需要用户自行引入POI库。 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 将按钮与方法绑定，可在工具中指定，也可直接在fxml文件对应按钮处加上onAction～ Controller 行为响应 123456789101112131415161718192021222324252627282930313233@FXMLvoid exportAreaResourceTemplate(ActionEvent event) { String defaultFileName = \"AreaResourceTemplate.xlsx\"; File file = FileChooserUtil.chooseSaveFile(defaultFileName, new FileChooser.ExtensionFilter(\"All Excel\", \"*.xlsx\"), new FileChooser.ExtensionFilter(\"XLS\", \"*.xls\"), new FileChooser.ExtensionFilter(\"XLSX\", \"*.xlsx\")); if (file != null) { //开启IO ExcelWriter writer = ExcelUtil.getWriter(file.getPath()); //写入数据 List&lt;String&gt; row1 = CollUtil.newArrayList(\"入流流量Qi (L/s)\", \"入流污染物浓度Ci (mg/L)\", \"出流流量Qj (L/s)\", \"出流污染物浓度Cj (mg/L)\", \"垫面系数Mk (mg/m2 s)\", \"垫面面积Sk (m2)\"); List&lt;String&gt; row2 = CollUtil.newArrayList(\"22\", \"20\", \"6\", \"5\", \"6\", \"5\"); List&lt;String&gt; row3 = CollUtil.newArrayList(\"7\", \"8\", \"6.5\", \"8\", \"16\", \"5\"); List&lt;String&gt; row4 = CollUtil.newArrayList(\"22\", \"20\", \"4\", \"11\", \"7\", \"6\"); List&lt;String&gt; row5 = CollUtil.newArrayList(\"5\", \"8\"); List&lt;List&lt;String&gt;&gt; rows = CollUtil.newArrayList(row1, row2, row3, row4, row5); //调整excel格式 writer.merge(5, \"删除下方数据行(第三行开始)重新填数据即可\"); writer.setColumnWidth(0,25); writer.setColumnWidth(1,25); writer.setColumnWidth(2,25); writer.setColumnWidth(3,25); writer.setColumnWidth(4,25); writer.setColumnWidth(5,25); writer.write(rows, true); //关闭IO writer.close(); }} 3.用户导入excel如果只按结果考虑，接下来的步骤分为导入excel文件和直接计算输出结果两步即可。 但站在用户角度，我加入了导入数据的表格显示，这样有几点好处 方便用户检查数据是否导入完整（谁知道他按不按模板格式来。。。或者有漏错之类 提高用户体验（看着舒服 3.1 用户界面表格显示重点是使用到 JFXTreeTableView 组件。 由于入流、出流和垫面三组表格除行数外，结构完全相同，取入流组说明。 以下为 JFXTreeTableView 的初始化，别问为什么，它设计就是让你这么用的哈。 每行有两个数据，先准备一个entity带两个属性表示每一行～ 12345678910111213141516public class DoubleAttribute extends RecursiveTreeObject&lt;DoubleAttribute&gt; { StringProperty first; StringProperty second; public DoubleAttribute(String first, String second) { this.first = new SimpleStringProperty(first); this.second = new SimpleStringProperty(second); } public String getFirst() {return first.get();} public StringProperty firstProperty() {return first;} public void setFirst(String first) {this.first.set(first);} public String getSecond() {return second.get();} public StringProperty secondProperty() {return second;} public void setSecond(String second) {this.second.set(second);}} 初始化表两列的表头，并定义表身中每行每列的数据怎么获取～ 即 DoubleAttribute的 first 和 second 属性分别表示每行的 Qi、 Ci 。 1234567891011121314151617181920212223242526@FXMLprivate JFXTreeTableView&lt;DoubleAttribute&gt; inTable;@FXMLpublic void initialize() { JFXTreeTableColumn&lt;DoubleAttribute, String&gt; qi = new JFXTreeTableColumn&lt;&gt; (\"Qi(L/s)\"); qi.setPrefWidth(83); qi.setCellValueFactory(new Callback&lt;TreeTableColumn.CellDataFeatures&lt;DoubleAttribute, String&gt;, ObservableValue&lt;String&gt;&gt;() { @Override public ObservableValue&lt;String&gt; call(TreeTableColumn.CellDataFeatures&lt;DoubleAttribute, String&gt; param) { //重点就是这个 return param.getValue().getValue().firstProperty(); } }); JFXTreeTableColumn&lt;DoubleAttribute, String&gt; ci = new JFXTreeTableColumn&lt;&gt;(\"Ci(mg/L)\"); ci.setPrefWidth(83); ci.setCellValueFactory(new Callback&lt;TreeTableColumn.CellDataFeatures&lt;DoubleAttribute, String&gt;, ObservableValue&lt;String&gt;&gt;() { @Override public ObservableValue&lt;String&gt; call(TreeTableColumn.CellDataFeatures&lt;DoubleAttribute, String&gt; param) { return param.getValue().getValue().secondProperty(); } }); inTable.getColumns().setAll(qi, ci);} 3.2 选择目标文件同样在工具类 FileChooserUtil 中， 12345678910111213141516public class FileChooserUtil { public static File chooseOpenFile(FileChooser.ExtensionFilter... extensionFilter) { File file = null; try { FileChooser fileChooser = new FileChooser(); fileChooser.setInitialDirectory(new File(System.getProperty(\"user.home\"))); if (extensionFilter != null) { fileChooser.getExtensionFilters().addAll(extensionFilter); } file = fileChooser.showOpenDialog(new Stage()); } catch (NullPointerException e) { e.printStackTrace(); } return file; }} 3.3 导入Excel文件在导入Excel的同时，我做了三件事， 每行数据按 DoubleAttribute 分别收集至不同list，后set进不同的 JFXTreeTableView 表格 用 inSum、outSum、smSum 分别统计$\\sum_{i=1}^nC_iQ_i $、 $\\sum_{j=1}^pC_jQ_j $、$ \\sum_{k=1}^qm_kS_k $，便于之后 3.4 直接计算给出结果 用 inRowsCount、outRowsCount、smRowsCount 分别统计每组行数，并分别set进对应的 JFXTextField 组件 inRowsCountText、outRowsCountText、smRowsCountText 显示在表格下方 下面的步骤包含三组表，可能有点长，但大多重复比较好理解，我尽量注释～ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@FXMLvoid importAreaResourceExcel(ActionEvent event) { File file = FileChooserUtil.chooseOpenFile( new FileChooser.ExtensionFilter(\"All Excel\", \"*.xlsx\"), new FileChooser.ExtensionFilter(\"XLS\", \"*.xls\"), new FileChooser.ExtensionFilter(\"XLSX\", \"*.xlsx\")); if (file == null) return; //读取所有的数据 ExcelReader reader = ExcelUtil.getReader(file); List&lt;List&lt;Object&gt;&gt; readAll = reader.read(); //初始化统计值 inSum = outSum = smSum = 0; inRowsCount = outRowsCount = smRowsCount = 0; //初始化按每行数据DoubleAttribute的List ObservableList&lt;DoubleAttribute&gt; inCols = FXCollections.observableArrayList(); ObservableList&lt;DoubleAttribute&gt; outCols = FXCollections.observableArrayList(); ObservableList&lt;DoubleAttribute&gt; smCols = FXCollections.observableArrayList(); //从第三行开始处理数据 for (int i = 2; i &lt; readAll.size() ; i++) { List&lt;Object&gt; readLine = readAll.get(i); //前文提到的亮点来了，由于n、p、q是不确定的，读取时可能有空值，用这种方法确认不为空再读取 if (readLine.size() &gt; 1 &amp;&amp; readLine.get(0) != null &amp;&amp; readLine.get(1) != null){ String a = String.valueOf(readLine.get(0)); String b = String.valueOf(readLine.get(1)); //入流的每行数据按DoubleAttribute注入到list inCols.add(new DoubleAttribute(a,b)); //统计入流集 inSum += Double.valueOf(a) * Double.valueOf(b); //统计行数 inRowsCount++; } if (readLine.size() &gt; 3 &amp;&amp; readLine.get(2) != null &amp;&amp; readLine.get(3) != null){ String a = String.valueOf(readLine.get(2)); String b = String.valueOf(readLine.get(3)); outCols.add(new DoubleAttribute(a,b)); outSum += Double.valueOf(a) * Double.valueOf(b); outRowsCount++; } if (readLine.size() &gt; 5 &amp;&amp; readLine.get(4) != null &amp;&amp; readLine.get(5) != null){ String a = String.valueOf(readLine.get(4)); String b = String.valueOf(readLine.get(5)); smCols.add(new DoubleAttribute(a,b)); smSum += Double.valueOf(a) * Double.valueOf(b); smRowsCount++; } } //带着每行数据的list set到JFXTreeTableView表格 final TreeItem&lt;DoubleAttribute&gt; rootInCols = new RecursiveTreeItem&lt;DoubleAttribute&gt;(inCols, RecursiveTreeObject::getChildren); inTable.setRoot(rootInCols); inTable.setShowRoot(false); final TreeItem&lt;DoubleAttribute&gt; rootOutCols = new RecursiveTreeItem&lt;DoubleAttribute&gt;(outCols, RecursiveTreeObject::getChildren); outTable.setRoot(rootOutCols); outTable.setShowRoot(false); final TreeItem&lt;DoubleAttribute&gt; rootSmCols = new RecursiveTreeItem&lt;DoubleAttribute&gt;(smCols, RecursiveTreeObject::getChildren); smTable.setRoot(rootSmCols); smTable.setShowRoot(false); //每个表格下的JFXTextField组件显示行数 inRowsCountText.setText(\"共\" + inRowsCount + \"行\"); inRowsCountText.setVisible(true); outRowsCountText.setText(\"共\" + outRowsCount + \"行\"); outRowsCountText.setVisible(true); smRowsCountText.setText(\"共\" + smRowsCount + \"行\"); smRowsCountText.setVisible(true);} 3.4 计算结果就非常简单了，前面已统计好，只需一步 12345@FXMLvoid calAreaSourceRate(ActionEvent event) { double res = (1 - outSum/(inSum + smSum))*100; areaRValue.setText(String.format(\"%.2f\", res));} 4.总结到此为止，以上四篇就是我做这个应用的完整思路和学习记录啦～ 最后的交付， （这个就不放源码啦，一是关键点都发了没有参考必要，二是实在算不上一个好作品不好意思哈哈 总的来说，用起来并不难，思维方式也很容易理解。 麻烦的是寻找未知事物和独立解决问题的过程， 这也是一种锻炼吧～","link":"/2020/0402/javafx04-excel.html"},{"title":"Vue+Springboot项目部署（一）环境准备","text":"项目前后端分别开发测试对调完成后，一方面Vue前端项目编译打包，剩下一堆 js、css 以及 html文件等静态资源文件，另一方面Springboot后端项目构建jar包。 采用 Nginx + Server 的方式部署～ 环境准备服务器选用的是阿里云ECS的Ubuntu 18.04.3，与CentOS 的操作基本类似，供参考 常见的软件安装有以下四种方式：源码、二进制（rpm）、yum、脚本安装。 二进制（rpm）安装 ：只需少量的命令，如 apt-get install nginx 但无法解决软件包的依赖关系。 yum安装：自动解决软件依赖性，虽操作更简单方便，但同上无法干预，不能按需安装。 源码安装：可以设定参数，按照需求，进行安装，且可选择安装的版本，灵活性较大。 脚本安装：即把复杂的软件包安装过程写成了程序脚本。讲解不考虑。 Nginx安装考虑到后续在nginx引入gzip模块，使用源码安装！ 安装编译环境gcc g++的依赖库 (阿里云ECS自带，可省，不过试了也无妨～) 12sudo apt-get install build-essentialsudo apt-get install libtool 安装nginx的依赖库 pcre zlib ssl 1sudo apt-get install libpcre3 libpcre3-dev zlib1g-dev openssl 安装nginx 12wget http://nginx.org/download/nginx-1.17.0.tar.gztar -zxvf nginx-1.17.0.tar.gz cd到解压目录，开始编译安装。引入gzip模块，nginx静态压缩的条件。 123./configure --with-http_gzip_static_modulemakemake install 安装目录：/usr/local/nginx 常用命令12345cd sbin/./nginx #启动vim conf/nginx.conf #修改配置文件./nginx -s reload #重新加载配置文件启动 Docker安装二进制（rpm）安装即可，具体可参照官网 12345678910111213sudo apt-get update# 允许apt通过HTTPS使用仓库sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common# 添加Docker官方GPG keycurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# 设置Docker稳定版仓库sudo add-apt-repository \"deb [arch=arm64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"# 安装sudo apt-get install docker-ce docker-ce-cli containerd.io docker –version 查到版本信号即安装成功！ 常用命令1234567891011121314151617181920212223242526# 启动/停止/重启dockersudo service docker start/stop/restart# 列出镜像docker images# 拉取镜像docker image pull 容器名:Tag# 删除镜像docker rmi 镜像名# 创建容器docker run [选项参数] 镜像名 # 正在运行的容器docker ps# 全部容器docker ps -a# 停止/启动的容器docker stop/start 容器名或容器id# 删除容器docker rm 容器名或容器id","link":"/2020/0325/vue-springboot-deploy01.html"},{"title":"Vue+Springboot项目部署（二）启动","text":"以我的Vue+Springboot项目lovecanfly为例说明。 1.后端后端采用docker部署。项目使用了mysql数据库，除了springboot项目本身用docker部署，为方便也使用docker的mysql容器。 容器通信：多个容器之间需要通信，以往使用的–link方法在互连的容器数量较多时，复杂度会显著增加（官网已不建议）。这里推荐使用自定义bridge网络通信。 bridge是docker默认的网络驱动模型。 默认的bridge上的容器只能通过子网IP互连，无法通过DNS解析名称或别名。但docker无法保证容器重启后的子网IP地址不变，所以更好的方式是通过别名进行互联。 自定义bridge在网络中加入了DNS服务器，将容器名与IP地址进行匹配，解决了该问题，操作简便。 1.1 创建自定义bridge网络1docker network create lovecanfly-net 1.2 创建并运行mysql容器12345# 拉取 mysql 5.7镜像docker pull mysql:5.7# 创建mysql容器docker run -d -p 3306:3306 --network lovecanfly-net --name zrkmysql -e MYSQL_ROOT_PASSWORD=XXXXXXX mysql:5.7 -d：容器后台运行 -p：端口映射，此处映射 主机3306端口 到 容器的3306端口 –network：指定bridge网络 –name：容器名，此处命名为zrkmysql。后续web则可通过容器名zrkmysql连接mysql -e：配置信息，此处配置mysql的root用户的登陆密码 1.3 创建并运行springboot容器 在application.properties里更改数据库连接url 更改连接的ip名为之前mysql设置好的容器名。 接下来，一种比较方便的做法是直接一键打包部署，可以参考松哥的这篇文章：一键部署 Spring Boot 到远程 Docker 容器。这种方法是在IDEA安装docker插件，更改远程连接服务器上的docker配置，使IDEA可远程连接服务器上的docker，一键即可在本地打jar包同时构建镜像。 但这种做法在更改服务器上docker配置将无密码状态暴露端口给外界，方便自己也方便了他人，有明显的安全风险。我第一次也是这么做的，结果第二天阿里云上的服务器就被攻击安装并运行了挖矿容器～所以不太推荐哈～ 打jar包 选择如图或在项目跟路径输入mvn package打jar包，成功后会在target目录生成jar包 编写Dockerfile文件 新建一个Dockerfile文件，编辑内容如下： 12345FROM java:8VOLUME /tmpADD target/lovecanfly-0.0.1-SNAPSHOT.jar app.jarRUN bash -c 'touch /app.jar'ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"] 简单说明： 基础镜像使用java，VOLUME 指定了临时文件目录为/tmp，将jar包添加到容器中并更名为app.jar 按命令行 java -jar /app.jar 运行jar包。 制作镜像及运行容器 把 lovecanfly-0.0.1-SNAPSHOT.jar app.jar 和 Dockerfile上传至服务器同一目录。 进入该目录， 1docker build -t lovecanfly . # 注意最后的. 不可省, -t 为指定镜像名 生成并运行容器， 1docker run -d -p 8081:8081 --network lovecanfly-net --name lovecanfly lovecanfly 所有步骤完成，输入 docker ps 容器成功运行即可～ 2.前端前端的操作简单的多，但考虑到减少项目运行时的首屏加载时间，提高用户体验。 采用nginx静态压缩，提前把静态文件压缩成 .gz 格式。 （具体的压缩方式可参考： 首页加载速度提高了5倍 前端安装插件 1npm install compression-webpack-plugin -D 我使用的是vue-cli 4，在项目根路径下的vue.config.js 1234567891011121314151617const CompressionPlugin = require(\"compression-webpack-plugin\");module.exports = { configureWebpack: config =&gt; { if (process.env.NODE_ENV === 'production') { return { plugins: [ new CompressionPlugin({ test: /\\.js$|\\.html$|\\.css/, threshold: 1024, deleteOriginalAssets: false }) ] } } }} 然后 build，在项目dist文件夹中生成带.gz格式静态文件即可。 3.Nginx配置之前在安装nginx时已引入gzip静态模块，vim /usr/local/nginx/conf/nginx.conf 配置nginx 12345678910111213141516171819202122232425262728293031gzip_static on; # 开启静态gzip压缩upstream lovecanfly{ # 上游server名称，与 proxy_pass http://lovecanfly 对应 server 127.0.0.1:8081 weight=2;}server { listen 80; #访问端口 server_name lovecanfly.zhouruikang.cn; # 访问域名 # 访问项目url: lovecanfly.zhouruikang.cn/index.html, # 配置 / 直接转发 /index.html，即访问lovecanfly.zhouruikang.cn即可 rewrite ^/$ /index.html redirect; location ~ .*\\.(js|css|ico|png|jpg|eot|svg|ttf|woff|html|txt|pdf|) { root /usr/local/nginx/html/lovecanfly; #所有静态文件直接读取硬盘 index index.html index.htm; expires 7d; #缓存7天 } location /{ proxy_pass http://lovecanfly; # 访问api转发上游server tcp_nodelay on; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; }} 保存后， 1/usr/local/nginx/sbin/nginx -s reload 4.启动项目之前前端dist目录下的静态文件，上传至nginx刚配置好的 /usr/local/nginx/html/lovecanfly 路径中。访问刚才设置好的域名server_name lovecanfly.zhouruikang.cn;即可！ 前提是，要先将域名zhouruikang.cn与服务器IP对应哦～太简单就省啦。","link":"/2020/0326/vue-springboot-deploy02.html"}],"tags":[{"name":"javafx","slug":"javafx","link":"/tags/javafx/"},{"name":"jfoenix","slug":"jfoenix","link":"/tags/jfoenix/"},{"name":"scene builder","slug":"scene-builder","link":"/tags/scene-builder/"},{"name":"java桌面开发","slug":"java桌面开发","link":"/tags/java%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"},{"name":"fontawesomefx","slug":"fontawesomefx","link":"/tags/fontawesomefx/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"drawerNavigation","slug":"drawerNavigation","link":"/tags/drawerNavigation/"},{"name":"javafx - excel","slug":"javafx-excel","link":"/tags/javafx-excel/"},{"name":"poi","slug":"poi","link":"/tags/poi/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"部署","slug":"部署","link":"/tags/%E9%83%A8%E7%BD%B2/"}],"categories":[{"name":"javafx","slug":"javafx","link":"/categories/javafx/"},{"name":"项目部署","slug":"项目部署","link":"/categories/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"}]}