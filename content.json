{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"java开发桌面应用（一）JavaFx初体验","text":"故事发生在两个月前，哈工大的同学找到我，他的老师之前接了个海绵城市系统评价相关的项目，最后的提交里需要有一个桌面应用。之前我对桌面开发没多了解，但想到咱java无所不能，加上顺手谷歌一下看到javafx能做。既然能做那就不是问题，帮他这个忙啦～ 目前主流的桌面开发，跨平台用qt，不跨平台用winform或wpf。 javafx虽然不太主流，但是也能做啦～ 常用的开发套路：javafx 框架 + Jfoenix UI控件 + Scene Builder可视化工具 下面举个简单的小栗子来初步感受吧～ （源码记录 https://github.com/ZhouRuikang015/javafx-havefun 环境准备： IntelliJ IDEA JDK 1.8 Scene Builder 8.5.0 1.新建一个javafx项目使用IDEA自带的新建项目菜单即可 目录结构如下，直接点击Main运行，效果如右图 接下来可以大致感受javafx框架的想法，项目从Main.java进入，加载view层sample.fxml，窗口设置title和scene参数后展出。sample.fxml与controller层Controller.java进行行为绑定。与MVC类似，理解起来比较容易，接下来就开始玩吧～ 2.添加Maven为方便引入三方库管理项目，引入Maven。 首先将设置里Maven配置修改为自己提前安装好的maven地址。 引入maven 右键项目名选择 Add Framework Support... ，选择Maven确认，并修改一下目录结构。 注：将sample.fxml移动到resource目录下需修改Main.java中的加载路径FXMLLoader.load(getClass().getResource(&quot;/sample.fxml&quot;)) 3.引入Jfoenix UI库Jfoenix项目地址及Components演示 项目引入：pom.xml 文件里添加 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.jfoenix&lt;/groupId&gt; &lt;artifactId&gt;jfoenix&lt;/artifactId&gt; &lt;version&gt;8.0.8&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; scene builder工具引入 图中第二步从Maven仓库找到刚下载好的 jfoenix-8.0.8.jar，第三步全部或按需引入。 完成后在Library的Custom栏即引入的Jfoenix组件。 4.使用scene builder编写界面通过scene builder工具可视化编写.fxml视图文件。 打开设置，建立IDEA与scene builder工具关联 这样选中sample.fxml文件右键点击 Open In SceneBuilder 即可直接打开scene builder可视化编辑该文件。 scene builder编辑演示 简单说明， 图中引入三个组件，AnchorPane做背景板，一个按钮JFXButton，一个文本栏JFXTextField 右侧code栏处，JFXButton的Id名设置为button，响应方法名为changeInput。JFXTextField的Id名为textField，无响应方法。 左侧Controller指定sample.fxml的控制器Controller.java，方便自动生成Controller代码 使用自动生成的Controller代码 打开scene builder工具左上角 View / Show Simple Controller Skeleton，复制粘贴至项目中Controller.java，然后再编辑省时省力～ 更新项目中sample.fxml 工具里 点保存 ！！。 预览效果 在scene builder工具使用中不免想预览界面效果，左上角 Preview / Show Preview in Window 5.初体验 简单编写Controller.java完成组件的行为响应。 1234567891011121314151617181920212223242526package sample;import com.jfoenix.controls.JFXButton;import com.jfoenix.controls.JFXTextField;import javafx.event.ActionEvent;import javafx.fxml.FXML;public class Controller { @FXML private JFXButton button; @FXML private JFXTextField textField; @FXML void changeInput(ActionEvent event) { String text = textField.getText(); if (text.equals(\"hello\")){ textField.setText(\"world!\"); }else{ textField.setText(\"\"); } }} 运行效果 还挺好玩的～","link":"/2020/0327/javafx01-helloworld.html"},{"title":"Vue+Springboot项目部署（一）环境准备","text":"项目前后端分别开发测试对调完成后，一方面Vue前端项目编译打包，剩下一堆 js、css 以及 html文件等静态资源文件，另一方面Springboot后端项目构建jar包。 采用 Nginx + Server 的方式部署～ 环境准备服务器选用的是阿里云ECS的Ubuntu 18.04.3，与CentOS 的操作基本类似，供参考 常见的软件安装有以下四种方式：源码、二进制（rpm）、yum、脚本安装。 二进制（rpm）安装 ：只需少量的命令，如 apt-get install nginx 但无法解决软件包的依赖关系。 yum安装：自动解决软件依赖性，虽操作更简单方便，但同上无法干预，不能按需安装。 源码安装：可以设定参数，按照需求，进行安装，且可选择安装的版本，灵活性较大。 脚本安装：即把复杂的软件包安装过程写成了程序脚本。讲解不考虑。 Nginx安装考虑到后续在nginx引入gzip模块，使用源码安装！ 安装编译环境gcc g++的依赖库 (阿里云ECS自带，可省，不过试了也无妨～) 12sudo apt-get install build-essentialsudo apt-get install libtool 安装nginx的依赖库 pcre zlib ssl 1sudo apt-get install libpcre3 libpcre3-dev zlib1g-dev openssl 安装nginx 12wget http://nginx.org/download/nginx-1.17.0.tar.gztar -zxvf nginx-1.17.0.tar.gz cd到解压目录，开始编译安装。引入gzip模块，nginx静态压缩的条件。 123./configure --with-http_gzip_static_modulemakemake install 安装目录：/usr/local/nginx 常用命令12345cd sbin/./nginx #启动vim conf/nginx.conf #修改配置文件./nginx -s reload #重新加载配置文件启动 Docker安装二进制（rpm）安装即可，具体可参照官网 12345678910111213sudo apt-get update# 允许apt通过HTTPS使用仓库sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common# 添加Docker官方GPG keycurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# 设置Docker稳定版仓库sudo add-apt-repository \"deb [arch=arm64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"# 安装sudo apt-get install docker-ce docker-ce-cli containerd.io docker –version 查到版本信号即安装成功！ 常用命令1234567891011121314151617181920212223242526# 启动/停止/重启dockersudo service docker start/stop/restart# 列出镜像docker images# 拉取镜像docker image pull 容器名:Tag# 删除镜像docker rmi 镜像名# 创建容器docker run [选项参数] 镜像名 # 正在运行的容器docker ps# 全部容器docker ps -a# 停止/启动的容器docker stop/start 容器名或容器id# 删除容器docker rm 容器名或容器id","link":"/2020/0325/vue-springboot-deploy01.html"},{"title":"Vue+Springboot项目部署（二）启动","text":"以我的Vue+Springboot项目lovecanfly为例说明。 1.后端后端采用docker部署。项目使用了mysql数据库，除了springboot项目本身用docker部署，为方便也使用docker的mysql容器。 容器通信：多个容器之间需要通信，以往使用的–link方法在互连的容器数量较多时，复杂度会显著增加（官网已不建议）。这里推荐使用自定义bridge网络通信。 bridge是docker默认的网络驱动模型。 默认的bridge上的容器只能通过子网IP互连，无法通过DNS解析名称或别名。但docker无法保证容器重启后的子网IP地址不变，所以更好的方式是通过别名进行互联。 自定义bridge在网络中加入了DNS服务器，将容器名与IP地址进行匹配，解决了该问题，操作简便。 1.1 创建自定义bridge网络1docker network create lovecanfly-net 1.2 创建并运行mysql容器12345# 拉取 mysql 5.7镜像docker pull mysql:5.7# 创建mysql容器docker run -d -p 3306:3306 --network lovecanfly-net --name zrkmysql -e MYSQL_ROOT_PASSWORD=XXXXXXX mysql:5.7 -d：容器后台运行 -p：端口映射，此处映射 主机3306端口 到 容器的3306端口 –network：指定bridge网络 –name：容器名，此处命名为zrkmysql。后续web则可通过容器名zrkmysql连接mysql -e：配置信息，此处配置mysql的root用户的登陆密码 1.3 创建并运行springboot容器 在application.properties里更改数据库连接url 更改连接的ip名为之前mysql设置好的容器名。 接下来，一种比较方便的做法是直接一键打包部署，可以参考松哥的这篇文章：一键部署 Spring Boot 到远程 Docker 容器。这种方法是在IDEA安装docker插件，更改远程连接服务器上的docker配置，使IDEA可远程连接服务器上的docker，一键即可在本地打jar包同时构建镜像。 但这种做法在更改服务器上docker配置将无密码状态暴露端口给外界，方便自己也方便了他人，有明显的安全风险。我第一次也是这么做的，结果第二天阿里云上的服务器就被攻击安装并运行了挖矿容器～所以不太推荐哈～ 打jar包 选择如图或在项目跟路径输入mvn package打jar包，成功后会在target目录生成jar包 编写Dockerfile文件 新建一个Dockerfile文件，编辑内容如下： 12345FROM java:8VOLUME /tmpADD target/lovecanfly-0.0.1-SNAPSHOT.jar app.jarRUN bash -c 'touch /app.jar'ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"] 简单说明： 基础镜像使用java，VOLUME 指定了临时文件目录为/tmp，将jar包添加到容器中并更名为app.jar 按命令行 java -jar /app.jar 运行jar包。 制作镜像及运行容器 把 lovecanfly-0.0.1-SNAPSHOT.jar app.jar 和 Dockerfile上传至服务器同一目录。 进入该目录， 1docker build -t lovecanfly . # 注意最后的. 不可省, -t 为指定镜像名 生成并运行容器， 1docker run -d -p 8081:8081 --network lovecanfly-net --name lovecanfly lovecanfly 所有步骤完成，输入 docker ps 容器成功运行即可～ 2.前端前端的操作简单的多，但考虑到减少项目运行时的首屏加载时间，提高用户体验。 采用nginx静态压缩，提前把静态文件压缩成 .gz 格式。 （具体的压缩方式可参考： 首页加载速度提高了5倍 前端安装插件 1npm install compression-webpack-plugin -D 我使用的是vue-cli 4，在项目根路径下的vue.config.js 1234567891011121314151617const CompressionPlugin = require(\"compression-webpack-plugin\");module.exports = { configureWebpack: config =&gt; { if (process.env.NODE_ENV === 'production') { return { plugins: [ new CompressionPlugin({ test: /\\.js$|\\.html$|\\.css/, threshold: 1024, deleteOriginalAssets: false }) ] } } }} 然后 build，在项目dist文件夹中生成带.gz格式静态文件即可。 3.Nginx配置之前在安装nginx时已引入gzip静态模块，vim /usr/local/nginx/conf/nginx.conf 配置nginx 12345678910111213141516171819202122232425262728293031gzip_static on; # 开启静态gzip压缩upstream lovecanfly{ # 上游server名称，与 proxy_pass http://lovecanfly 对应 server 127.0.0.1:8081 weight=2;}server { listen 80; #访问端口 server_name lovecanfly.zhouruikang.cn; # 访问域名 # 访问项目url: lovecanfly.zhouruikang.cn/index.html, # 配置 / 直接转发 /index.html，即访问lovecanfly.zhouruikang.cn即可 rewrite ^/$ /index.html redirect; location ~ .*\\.(js|css|ico|png|jpg|eot|svg|ttf|woff|html|txt|pdf|) { root /usr/local/nginx/html/lovecanfly; #所有静态文件直接读取硬盘 index index.html index.htm; expires 7d; #缓存7天 } location /{ proxy_pass http://lovecanfly; # 访问api转发上游server tcp_nodelay on; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; }} 保存后， 1/usr/local/nginx/sbin/nginx -s reload 4.启动项目之前前端dist目录下的静态文件，上传至nginx刚配置好的 /usr/local/nginx/html/lovecanfly 路径中。访问刚才设置好的域名server_name lovecanfly.zhouruikang.cn;即可！ 前提是，要先将域名zhouruikang.cn与服务器IP对应哦～太简单就省啦。","link":"/2020/0326/vue-springboot-deploy02.html"},{"title":"Helasda","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick llamasCreate a new post_.compactUnderscore.js1_.compact([0, 1, false, 2, '', 3]); 1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment lobe Dads","link":"/2020/0323/hello-world.html"}],"tags":[{"name":"javafx","slug":"javafx","link":"/tags/javafx/"},{"name":"jfoenix","slug":"jfoenix","link":"/tags/jfoenix/"},{"name":"scene builder","slug":"scene-builder","link":"/tags/scene-builder/"},{"name":"java桌面开发","slug":"java桌面开发","link":"/tags/java%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"部署","slug":"部署","link":"/tags/%E9%83%A8%E7%BD%B2/"}],"categories":[{"name":"javafx","slug":"javafx","link":"/categories/javafx/"},{"name":"项目部署","slug":"项目部署","link":"/categories/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"}]}